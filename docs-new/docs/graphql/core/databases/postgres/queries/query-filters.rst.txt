<div class="meta"
description="Filter query results and search queries on Postgres in Hasura"
keywords="hasura, docs, postgres, query, filter, search">

</div>

# Postgres: Filter query results / search queries

<div class="contents" backlinks="none" depth="2" local="">

Table of contents

</div>

## The **where** argument

You can use the `where` argument in your queries to filter results based
on some field’s values (even nested objects' fields). You can even use
multiple filters in the same `where` clause using the `_and` or the
`_or` operators.

For example, to fetch data for an author whose name is "Sidney":

``` graphql
query {
  authors(
    where: {name: {_eq: "Sidney"}}
  ) {
    id
    name
  }
}
```

You can also use nested objects\` fields to filter rows from a table and
also filter the nested objects as well.

For example, to fetch a list of authors who have articles with a rating
greater than 4 along with those articles:

``` graphql
query {
  authors (where: {articles: {rating: {_gt: 4}}}) {
    id
    name
    articles (where: {rating: {_gt: 4}}) {
      id
      title
      rating
    }
  }
}
```

Here `_eq` and `_gt` are examples of comparison operators that can be
used in the `where` argument to filter on equality.

You can see the complete specification of the `where` argument in the
`API reference <WhereExp>`.

## Comparison operators

Let’s take a look at different comparison operators that can be used to
filter results.

### Equality operators (\_eq, \_neq)

The `_eq` (equal to) or the `_neq` (not equal to) operators are
compatible with any Postgres type other than `json` or `jsonB` (like
`Integer`, `Float`, `Double`, `Text`, `Boolean`,
`Date`/`Time`/`Timestamp`, etc.).

For more details on equality operators and Postgres equivalents, refer
to the `API reference <generic_operators>`.

The following are examples of using the equality operators on different
types.

**Example: Integer (works with Double, Float, Numeric, etc.)**

Fetch data about an author whose `id` *(an integer field)* is equal to
3:

<div class="graphiql" view_only="" query="query {
  authors(
    where: {id: {_eq: 3}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;
      }
    ]
  }
}">

</div>

**Example: String or Text**

Fetch a list of authors with `name` *(a text field)* as "Sidney":

<div class="graphiql" view_only="" query="query {
  authors(
    where: {name: {_eq: &quot;Sidney&quot;}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;
      }
    ]
  }
}">

</div>

**Example: Boolean**

Fetch a list of articles that have not been published (`is_published` is
a boolean field):

<div class="graphiql" view_only="" query="query {
  articles(
    where: {is_published: {_eq: false}}
  ) {
    id
    title
    is_published
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 5,
        &quot;title&quot;: &quot;ut blandit&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 8,
        &quot;title&quot;: &quot;donec semper sapien&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 10,
        &quot;title&quot;: &quot;dui proin leo&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 14,
        &quot;title&quot;: &quot;congue etiam justo&quot;,
        &quot;is_published&quot;: false
      }
    ]
  }
}">

</div>

**Example: Date (works with Time, Timezone, etc.)**

Fetch a list of articles that were published on a certain date
(`published_on` is a Date field):

<div class="graphiql" view_only="" query="query {
  articles(
    where: {published_on: {_eq: &quot;2017-05-26&quot;}}
  ) {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      }
    ]
  }
}">

</div>

<div class="admonition">

Caveat for "null" values

By design, the `_eq` or `_neq` operators will not return rows with
`null` values.

To also return rows with `null` values, the `_is_null` operator needs to
be used along with these joined by the `_or` operator.

For example, to fetch a list of articles where the `is_published` column
is either `false` or `null`:

<div class="graphiql" view_only="" query="query {
  articles (
    where: {
      _or: [
        {is_published: {_eq: false}},
        {is_published: {_is_null: true}}
      ]
    }
  )
  {
    id
    title
    is_published
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;Robben Island&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;The Life of Matthias&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;All about Hasura&quot;,
        &quot;is_published&quot;: null
      },
    ]
  }
}">

</div>

</div>

### Greater than or less than operators (\_gt, \_lt, \_gte, \_lte)

The `_gt` (greater than), `_lt` (less than), `_gte` (greater than or
equal to), `_lte` (less than or equal to) operators are compatible with
any Postgres type other than `json` or `jsonB` (like `Integer`, `Float`,
`Double`, `Text`, `Boolean`, `Date`/`Time`/`Timestamp`, etc.).

For more details on greater than or less than operators and Postgres
equivalents, refer to the `API reference <generic_operators>`.

The following are examples of using these operators on different types:

**Example: Integer (works with Double, Float, etc.)**

Fetch a list of articles rated 4 or more (`rating` is an integer field):

<div class="graphiql" view_only="" query="query {
  articles(
    where: {rating: {_gte: 4}}
  ) {
    id
    title
    rating
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;rating&quot;: 4
      },
      {
        &quot;id&quot;: 7,
        &quot;title&quot;: &quot;nisl duis ac&quot;,
        &quot;rating&quot;: 4
      },
      {
        &quot;id&quot;: 17,
        &quot;title&quot;: &quot;montes nascetur ridiculus&quot;,
        &quot;rating&quot;: 5
      }
    ]
  }
}">

</div>

**Example: String or Text**

Fetch a list of authors whose names begin with M or any letter that
follows M *(essentially, a filter based on a dictionary sort)*:

<div class="graphiql" view_only="" query="query {
  authors(
    where: {name: {_gt: &quot;M&quot;}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;name&quot;: &quot;Ninnetta&quot;
      }
    ]
  }
}">

</div>

**Example: Date (works with Time, Timezone, etc.)**

Fetch a list of articles that were published on or after date
"01/01/2018":

<div class="graphiql" view_only="" query="query {
  articles(
    where: {published_on: {_gte: &quot;2018-01-01&quot;}}
  ) {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;published_on&quot;: &quot;2018-06-10&quot;
      },
      {
        &quot;id&quot;: 6,
        &quot;title&quot;: &quot;sapien ut&quot;,
        &quot;published_on&quot;: &quot;2018-01-08&quot;
      },
      {
        &quot;id&quot;: 13,
        &quot;title&quot;: &quot;vulputate elementum&quot;,
        &quot;published_on&quot;: &quot;2018-03-10&quot;
      },
      {
        &quot;id&quot;: 15,
        &quot;title&quot;: &quot;vel dapibus at&quot;,
        &quot;published_on&quot;: &quot;2018-01-02&quot;
      }
    ]
  }
}">

</div>

### List based search operators (\_in, \_nin)

The `_in` (in a list) and `_nin` (not in list) operators are used to
compare field values to a list of values. They are compatible with any
Postgres type other than `json` or `jsonB` (like `Integer`, `Float`,
`Double`, `Text`, `Boolean`, `Date`/`Time`/`Timestamp`, etc.).

For more details on list based search operators and Postgres
equivalents, refer to the `API reference <generic_operators>`.

The following are examples of using these operators on different types:

**Example: Integer (works with Double, Float, etc.)**

Fetch a list of articles rated 1, 3 or 5:

<div class="graphiql" view_only="" query="query {
  articles(
    where: {rating: {_in: [1,3,5]}}
  ) {
    id
    title
    rating
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;rating&quot;: 1
      },
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;rating&quot;: 3
      },
      {
        &quot;id&quot;: 6,
        &quot;title&quot;: &quot;sapien ut&quot;,
        &quot;rating&quot;: 1
      },
      {
        &quot;id&quot;: 17,
        &quot;title&quot;: &quot;montes nascetur ridiculus&quot;,
        &quot;rating&quot;: 5
      }
    ]
  }
}">

</div>

**Example: String or Text**

Fetch a list of those authors whose names are NOT part of a list:

<div class="graphiql" view_only="" query="query {
  authors(
    where: {name: {_nin: [&quot;Justin&quot;,&quot;Sidney&quot;,&quot;April&quot;]}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;
      },
      {
        &quot;id&quot;: 5,
        &quot;name&quot;: &quot;Amii&quot;
      },
      {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;Corny&quot;
      }
    ]
  }
}">

</div>

### Text search or pattern matching operators (\_like, \_similar, \_regex, etc.)

The `_like`, `_nlike`, `_ilike`, `_nilike`, `_similar`, `_nsimilar`,
`_regex`, `_nregex`, `_iregex`, `_niregex` operators are used for
pattern matching on string/text fields.

For more details on text search operators and Postgres equivalents,
refer to the `API reference <text_operators>`.

**Example: \_like**

Fetch a list of articles whose titles contain the word “amet”:

<div class="graphiql" view_only="" query="query {
  articles(
    where: {title: {_like: &quot;%amet%&quot;}}
  ) {
    id
    title
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;title&quot;: &quot;sit amet&quot;
      }
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

`_like` is case-sensitive. Use `_ilike` for case-insensitive search.

</div>

**Example: \_similar**

Fetch a list of authors whose names begin with A or C:

<div class="graphiql" view_only="" query="query {
  authors(
    where: {name: {_similar: &quot;(A|C)%&quot;}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;
      },
      {
        &quot;id&quot;: 5,
        &quot;name&quot;: &quot;Amii&quot;
      },
      {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;Corny&quot;
      },
      {
        &quot;id&quot;: 8,
        &quot;name&quot;: &quot;April&quot;
      }
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

`_similar` is case-sensitive

</div>

**Example: \_regex**

Fetch a list of articles whose titles match the regex “\[ae\]met”:

<div class="graphiql" view_only="" query="query {
  articles(
    where: {title: {_regex: &quot;[ae]met&quot;}}
  ) {
    id
    title
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;cremet justo morbi&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;title&quot;: &quot;sit ametist&quot;
      }
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

`_regex` is case-sensitive. Use `_iregex` for case-insensitive search.

</div>

<div class="note">

<div class="title">

Note

</div>

`regex` operators are supported in in `v2.0.0` and above

</div>

### JSONB operators (\_contains, \_has_key, etc.)

The `_contains`, `_contained_in`, `_has_key`, `_has_keys_any` and
`_has_keys_all` operators are used to filter based on `JSONB` columns.

For more details on JSONB operators and Postgres equivalents, refer to
the `API reference <jsonb_operators>`.

**Example: \_contains**

Fetch all authors living within a particular pincode (present in
`address` JSONB column):

<div class="graphiql" view_only=""
query="query get_authors_in_pincode ($jsonFilter: jsonb){
  authors(
    where: {
      address: {_contains: $jsonFilter }
    }
  ) {
    id
    name
    address
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Ash&quot;,
        &quot;address&quot;: {
          &quot;street_address&quot;: &quot;161, 19th Main Road, Koramangala 6th Block&quot;,
          &quot;city&quot;: &quot;Bengaluru&quot;,
          &quot;state&quot;: &quot;Karnataka&quot;,
          &quot;pincode&quot;: 560095,
          &quot;phone&quot;: &quot;9090909090&quot;,
        }
      }
    ]
  }
}
:variables:
{
  &quot;jsonFilter&quot;: {
    &quot;pincode&quot;: 560095
  }
}">

</div>

**Example: \_has_key**

Fetch authors if the `phone` key is present in their JSONB `address`
column:

<div class="graphiql" view_only="" query="query get_authors_if_phone {
  authors(
    where: {
      address: {_has_key: &quot;phone&quot; }
    }
  ) {
    id
    name
    address
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Ash&quot;,
        &quot;address&quot;: {
          &quot;street_address&quot;: &quot;161, 19th Main Road, Koramangala 6th Block&quot;,
          &quot;city&quot;: &quot;Bengaluru&quot;,
          &quot;state&quot;: &quot;Karnataka&quot;,
          &quot;pincode&quot;: 560095,
          &quot;phone&quot;: &quot;9090909090&quot;
        }
      }
    ]
  }
}">

</div>

### PostGIS spatial relationship operators (\_st_contains, \_st_crosses, etc.)

The `_st_contains`, `_st_crosses`, `_st_equals`, `_st_intersects`,
`_st_3d_intersects`, `_st_overlaps`, `_st_touches`, `_st_within`,
`_st_d_within`, and `_st_3d_d_within` operators are used to filter based
on `geometry` like columns.

`_st_d_within` and `_st_intersects` can be used on `geography` columns
also (but their 3D variations are for `geometry` only).

For more details on spatial relationship operators and Postgres
equivalents, refer to the `API reference <geometry_operators>`.

Use JSON representation (see
[GeoJSON](https://tools.ietf.org/html/rfc7946)) of `geometry` and
`geography` values in `variables` as shown in the following examples:

**Example: \_st_within**

Fetch a list of geometry values which are within the given `polygon`
value:

<div class="graphiql" view_only=""
query="query geom_table($polygon: geometry){
  geom_table(
    where: {geom_col: {_st_within: $polygon}}
  ){
    id
    geom_col
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;geom_table&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;geom_col&quot;: {
          &quot;type&quot;: &quot;Point&quot;,
          &quot;coordinates&quot;: [
            1,
            2
          ]
        }
      }
    ]
  }
}
:variables:
{
  &quot;polygon&quot;: {
    &quot;type&quot;: &quot;Polygon&quot;,
    &quot;coordinates&quot;: [
      [
        [ 0, 0 ],
        [ 0, 2 ],
        [ 2, 2 ],
        [ 2, 0 ],
        [ 0, 0 ]
      ]
    ]
  }
}">

</div>

**Example: \_st_d\_within**

Fetch a list of `geometry` values which are 3 units from a given `point`
value:

<div class="graphiql" view_only=""
query="query geom_table($point: geometry){
  geom_table(
    where: {geom_col: {_st_d_within: {distance: 3, from: $point}}}
  ){
    id
    geom_col
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;geom_table&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;geom_col&quot;: {
          &quot;type&quot;: &quot;Point&quot;,
          &quot;coordinates&quot;: [
            1,
            2
          ]
        }
      },
      {
        &quot;id&quot;: 2,
        &quot;geom_col&quot;: {
          &quot;type&quot;: &quot;Point&quot;,
          &quot;coordinates&quot;: [
            3,
            0
          ]
        }
      }
    ]
  }
}
:variables:
{
  &quot;point&quot;: {
    &quot;type&quot;: &quot;Point&quot;,
    &quot;coordinates&quot;: [ 0, 0 ]
  }
}">

</div>

**Example: \_st_3d_d\_within**

This is completely analogous to the `_st_d_within` example above, the
only difference being that our coordinates now have three components
instead of two.

<div class="graphiql" view_only=""
query="query geom_table($point: geometry){
  geom_table(
    where: {geom_col: {_st_3d_d_within: {distance: 3, from: $point}}}
  ){
    id
    geom_col
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;geom_table&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;geom_col&quot;: {
          &quot;type&quot;: &quot;Point&quot;,
          &quot;coordinates&quot;: [
            1,
            2,
            1
          ]
        }
      },
      {
        &quot;id&quot;: 2,
        &quot;geom_col&quot;: {
          &quot;type&quot;: &quot;Point&quot;,
          &quot;coordinates&quot;: [
            3,
            0,
            0
          ]
        }
      }
    ]
  }
}
:variables:
{
  &quot;point&quot;: {
    &quot;type&quot;: &quot;Point&quot;,
    &quot;coordinates&quot;: [ 0, 0, 0 ]
  }
}">

</div>

**Example: \_st_3d_intersects**

Fetch a list of (3D) `geometry` values which intersect a given `polygon`
value:

<div class="graphiql" view_only=""
query="query geom_table($point: geometry){
  geom_table(
    where: {geom_col: {_st_3d_intersects: $polygon}}
  ){
    id
    geom_col
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;geom_table&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;geom_col&quot;: {
          &quot;type&quot;: &quot;LineString&quot;,
          &quot;coordinates&quot;:
            [
              [ -1, -2, -2 ],
              [ 3, 3, 2 ]
            ]
        }
      }
    ]
  }
}
:variables:
{
  &quot;polygon&quot;: {
    &quot;type&quot;: &quot;Polygon&quot;,
    &quot;coordinates&quot;: [
      [
        [0, 0, 0],
        [2, 0, 0],
        [1, 2, 0],
        [1, 1, 2],
        [0, 0, 0]
      ]
    ]
  }
}">

</div>

### Filter or check for null values (\_is_null)

Checking for null values can be achieved using the `_is_null` operator.

For more details on the `_is_null` operator and Postgres equivalent,
refer to the `API reference <null_expression>`.

**Example: Filter null values in a field**

Fetch a list of articles that have a value in the `published_on` field:

<div class="graphiql" view_only="" query="query {
  articles(
    where: {published_on: {_is_null: false}}
  ) {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;published_on&quot;: &quot;2017-08-09&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;published_on&quot;: &quot;2018-06-10&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      },
      {
        &quot;id&quot;: 4,
        &quot;title&quot;: &quot;vestibulum ac est&quot;,
        &quot;published_on&quot;: &quot;2017-03-05&quot;
      }
    ]
  }
}">

</div>

### Intersect operators on RASTER columns (\_st_intersects_rast, etc)

Intersect operators on columns with `raster` type are supported. Please
submit a feature request via
[GitHub](https://github.com/hasura/graphql-engine) if you want support
for more functions.

For more details on intersect operators on raster columns and Postgres
equivalents, refer to the `API reference <intersect_operators>`.

**Example: \_st_intersects_rast**

Filter the raster values which intersect the input raster value.

Executes the following SQL function:

``` sql
boolean ST_Intersects( raster <raster-col> , raster <raster-value> );
```

<div class="graphiql" view_only=""
query="query getIntersectingValues ($rast: raster){
  dummy_rast(where: {rast: {_st_intersects_rast: $rast}}){
    rid
    rast
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;dummy_rast&quot;: [
      {
        &quot;rid&quot;: 1,
        &quot;rast&quot;: &quot;01000001009A9999999999E93F9A9999999999E9BF000000000000F0BF000000000000104000000000000000000000000000000000E610000005000500440000010101000101010101010101010101010101010001010100&quot;
      },
      {
        &quot;rid&quot;: 2,
        &quot;rast&quot;: &quot;0100000100166C8E335B91F13FE2385B00285EF6BF360EE40064EBFFBF8D033900D9FA134000000000000000000000000000000000E610000005000500440000000101010001010101010101010101010101000101010000&quot;
      }
    ]
  }
}
:variables:
{
  &quot;rast&quot;: &quot;0100000100000000000000004000000000000000C00000000000000000000000000000084000000000000000000000000000000000E610000001000100440001&quot;
}">

</div>

**Example: \_st_intersects_geom_nband**

Filter the raster values which intersect the input geometry value and
optional band number.

Executes the following SQL function:

``` sql
boolean ST_Intersects( raster <raster-col> , geometry geommin , integer nband=NULL );
```

<div class="graphiql" view_only=""
query="query getIntersectingValues ($point: geometry!){
  dummy_rast(where: {rast: {_st_intersects_geom_nband: {geommin: $point}}}){
    rid
    rast
  }
}
:response:
{
 &quot;data&quot;: {
   &quot;dummy_rast&quot;: [
     {
       &quot;rid&quot;: 1,
       &quot;rast&quot;: &quot;01000001009A9999999999E93F9A9999999999E9BF000000000000F0BF000000000000104000000000000000000000000000000000E610000005000500440000010101000101010101010101010101010101010001010100&quot;
     },
     {
       &quot;rid&quot;: 2,
       &quot;rast&quot;: &quot;0100000100166C8E335B91F13FE2385B00285EF6BF360EE40064EBFFBF8D033900D9FA134000000000000000000000000000000000E610000005000500440000000101010001010101010101010101010101000101010000&quot;
     }
   ]
 }
}
:variables:
{
 &quot;point&quot;: {
   &quot;type&quot;: &quot;Point&quot;,
   &quot;coordinates&quot;: [
     1,
     2
   ],
   &quot;crs&quot;: {
     &quot;type&quot;: &quot;name&quot;,
     &quot;properties&quot;: {
       &quot;name&quot;: &quot;urn:ogc:def:crs:EPSG::4326&quot;
     }
   }
 }
}">

</div>

**Example: \_st_intersects_nband_geom**

Filter the raster values (with specified band number) which intersect
the input geometry value.

Executes the following SQL function:

``` sql
boolean ST_Intersects( raster <raster-col> , integer nband , geometry geommin );
```

<div class="graphiql" view_only=""
query="query getIntersectingValues ($point: geometry!){
  dummy_rast(where: {rast: {_st_intersects_nband_geom: {nband: 5 geommin: $point}}}){
    rid
    rast
  }
}
:response:
{
 &quot;data&quot;: {
   &quot;dummy_rast&quot;: [
     {
       &quot;rid&quot;: 1,
       &quot;rast&quot;: &quot;01000001009A9999999999E93F9A9999999999E9BF000000000000F0BF000000000000104000000000000000000000000000000000E610000005000500440000010101000101010101010101010101010101010001010100&quot;
     },
     {
       &quot;rid&quot;: 2,
       &quot;rast&quot;: &quot;0100000100166C8E335B91F13FE2385B00285EF6BF360EE40064EBFFBF8D033900D9FA134000000000000000000000000000000000E610000005000500440000000101010001010101010101010101010101000101010000&quot;
     }
   ]
 }
}
:variables:
{
 &quot;point&quot;: {
   &quot;type&quot;: &quot;Point&quot;,
   &quot;coordinates&quot;: [
     1,
     2
   ],
   &quot;crs&quot;: {
     &quot;type&quot;: &quot;name&quot;,
     &quot;properties&quot;: {
       &quot;name&quot;: &quot;urn:ogc:def:crs:EPSG::4326&quot;
     }
   }
 }
}">

</div>

### ltree operators (\_ancestor, \_matches, etc.)

Comparison operators on columns with `ltree`, `lquery` or `ltxtquery`
types are supported.

Please submit a feature request via
[GitHub](https://github.com/hasura/graphql-engine) if you want support
for more functions.

For more details on `ltree` operators and Postgres equivalents, refer to
the `API reference <ltree_operators>`.

**Example: \_ancestor**

Select ancestors of an <span class="title-ref">ltree</span> argument

<div class="graphiql" view_only="" query="query {
  tree (
    where: {path: {_ancestor: &quot;Tree.Collections.Pictures.Astronomy.Astronauts&quot;}}
  ) {
    path
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;tree&quot;: [
      {
        &quot;path&quot;: &quot;Tree&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures.Astronomy&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures.Astronomy.Astronauts&quot;
      }
    ]
  }
}">

</div>

**Example: \_matches_any**

Select <span class="title-ref">ltree</span> paths matching any <span
class="title-ref">lquery</span> regex in an array

<div class="graphiql" view_only="" query="query {
  tree (
    where: {path: {_matches_any: [&quot;*.Pictures.*&quot;, &quot;*.Hobbies.*&quot;]}}
  ) {
    path
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;tree&quot;: [
      {
        &quot;path&quot;: &quot;Tree.Hobbies&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Hobbies.Amateurs_Astronomy&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures.Astronomy&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures.Astronomy.Stars&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures.Astronomy.Galaxies&quot;
      },
      {
        &quot;path&quot;: &quot;Tree.Collections.Pictures.Astronomy.Astronauts&quot;
      }
    ]
  }
}">

</div>

## Filter based on failure of some criteria (\_not)

The `_not` operator can be used to fetch results for which some
condition does not hold true. i.e. to invert the filter set for a
condition.

**Example: \_not**

Fetch all authors who don't have any published articles:

<div class="graphiql" view_only="" query="{
  authors(
    where: {
      _not: {
        articles: { is_published: {_eq: true} }
      }
    }) {
    id
    name
    articles {
      title
      is_published
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 7,
        &quot;name&quot;: &quot;Berti&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;ipsum primis in&quot;,
            &quot;is_published&quot;: false
          }
        ]
      },
      {
        &quot;id&quot;: 9,
        &quot;name&quot;: &quot;Ninnetta&quot;,
        &quot;articles&quot;: []
      },
      {
        &quot;id&quot;: 10,
        &quot;name&quot;: &quot;Lyndsay&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;dui proin leo&quot;,
            &quot;is_published&quot;: false
          }
        ]
      }
    ]
  }
}">

</div>

## Using multiple filters in the same query (\_and, \_or)

You can group multiple parameters in the same `where` argument using the
`_and` or the `_or` operators to filter results based on more than one
criteria.

<div class="note">

<div class="title">

Note

</div>

You can use the `_or` and `_and` operators along with the `_not`
operator to create arbitrarily complex boolean expressions involving
multiple filtering criteria.

</div>

**Example: \_and**

Fetch a list of articles published in a specific time-frame (for
example: in year 2017):

<div class="graphiql" view_only="" query="query {
  articles (
    where: {
      _and: [
        { published_on: {_gte: &quot;2017-01-01&quot;}},
        { published_on: {_lte: &quot;2017-12-31&quot;}}
      ]
    }
  )
  {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;published_on&quot;: &quot;2017-08-09&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      },
      {
        &quot;id&quot;: 4,
        &quot;title&quot;: &quot;vestibulum ac est&quot;,
        &quot;published_on&quot;: &quot;2017-03-05&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;published_on&quot;: &quot;2017-05-16&quot;
      }
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

Certain `_and` expressions can be expressed in a simpler format using
some syntactic sugar. See the `API reference <AndExp>` for more details.

</div>

**Example: \_or**

Fetch a list of articles rated more than 4 or published after
"01/01/2018":

<div class="graphiql" view_only="" query="query {
  articles (
    where: {
      _or: [
        {rating: {_gte: 4}},
        {published_on: {_gte: &quot;2018-01-01&quot;}}
      ]
    }
  )
  {
    id
    title
    rating
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;rating&quot;: 3,
        &quot;published_on&quot;: &quot;2018-06-10&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;rating&quot;: 4,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      },
      {
        &quot;id&quot;: 6,
        &quot;title&quot;: &quot;sapien ut&quot;,
        &quot;rating&quot;: 1,
        &quot;published_on&quot;: &quot;2018-01-08&quot;
      },
      {
        &quot;id&quot;: 7,
        &quot;title&quot;: &quot;nisl duis ac&quot;,
        &quot;rating&quot;: 4,
        &quot;published_on&quot;: &quot;2016-07-09&quot;
      }
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

The `_or` operator expects an array of expressions as input. If an
object is passed as input it will behave like the `_and` operator as
explained in the `API reference <OrExp>`

</div>

## Filter nested objects

The `where` argument can be used in **array relationships** as well to
filter the nested objects. **Object relationships** have only one nested
object and hence they do not expose the `where` argument.

**Example:**

Fetch all authors with only their 5 rated articles:

<div class="graphiql" view_only="" query="{
  authors {
    id
    name
    articles(where: {rating: {_eq: 5}}) {
      title
      rating
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles&quot;: []
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;,
        &quot;articles&quot;: []
      },
      {
        &quot;id&quot;: 5,
        &quot;name&quot;: &quot;Amii&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;montes nascetur ridiculus&quot;,
            &quot;rating&quot;: 5
          }
        ]
      },
      {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;Corny&quot;,
        &quot;articles&quot;: []
      }
    ]
  }
}">

</div>

## Filter based on nested objects' fields

You can use the fields of nested objects as well to filter your query
results.

For example:

``` graphql
query {
  articles (where: {author: {name: {_eq: "Sidney"}}}) {
    id
    title
  }
}
```

The behaviour of the comparison operators depends on whether the nested
objects are a single object related via an object relationship or an
array of objects related via an array relationship.

-   In case of an **object relationship**, a row will be returned if the
    single nested object satisfies the defined condition.
-   In case of an **array relationship**, a row will be returned if
    **any of the nested objects** satisfy the defined condition.

Let's look at a few use cases based on the above:

### Fetch if the single nested object defined via an object relationship satisfies a condition

**Example:**

Fetch all articles whose author's name starts with "A":

<div class="graphiql" view_only="" query="{
  articles (
    where: {
      author: {
        name: { _similar: &quot;A%&quot;}
      }
    }
  ) {
    id
    title
    author {
      name
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Anjela&quot;
        }
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Anjela&quot;
        }
      },
      {
        &quot;id&quot;: 4,
        &quot;title&quot;: &quot;vestibulum ac est&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Amii&quot;
        }
      },
      {
        &quot;id&quot;: 12,
        &quot;title&quot;: &quot;volutpat quam pede&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Amii&quot;
        }
      },
      {
        &quot;id&quot;: 13,
        &quot;title&quot;: &quot;vulputate elementum&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;April&quot;
        }
      }
    ]
  }
}">

</div>

### Fetch if **any** of the nested objects defined via an array relationship satisfy a condition

**Example:**

Fetch all authors which have written at least one article which is rated
1:

<div class="graphiql" view_only="" query="{
  authors(
    where: {
      articles: {rating: {_eq: 1}}
    }
  ) {
    id
    name
    articles {
      title
      rating
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sem duis aliquam&quot;,
            &quot;rating&quot;: 1
          },
          {
            &quot;title&quot;: &quot;vel dapibus at&quot;,
            &quot;rating&quot;: 4
          }
        ]
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sit amet&quot;,
            &quot;rating&quot;: 1
          },
          {
            &quot;title&quot;: &quot;amet justo morbi&quot;,
            &quot;rating&quot;: 4
          }
        ]
      },
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sapien ut&quot;,
            &quot;rating&quot;: 1
          },
          {
            &quot;title&quot;: &quot;turpis eget&quot;,
            &quot;rating&quot;: 3
          },
          {
            &quot;title&quot;: &quot;congue etiam justo&quot;,
            &quot;rating&quot;: 4
          }
        ]
      }
    ]
  }
}">

</div>

### Fetch if **all** of the nested objects defined via an array relationship satisfy a condition

By default a row is returned if any of the nested objects satisfy a
condition. To achieve the above, we need to frame the `where` expression
as `{_not: {inverse-of-condition}}`. This reads as: fetch if not (any of
the nested objects satisfy the inverted condition) i.e. all of the
nested objects satisfy the condition.

For example:

| condition                           | where expression                            |
|-------------------------------------|---------------------------------------------|
| `{object: {field: {_eq: "value"}}}` | `{_not: {object: {field: {_neq: "value"}}}` |
| `{object: {field: {_gt: "value"}}}` | `{_not: {object: {field: {_lte: "value"}}}` |

**Example:**

Fetch all authors which have all of their articles published i.e. have
`{is_published {_eq: true}`.

<div class="graphiql" view_only="" query="{
  authors (
    where: {
      _not: {
        articles: {is_published: {_neq: true}}
      }
    }
  ) {
    id
    name
    articles {
      title
      is_published
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;vel dapibus at&quot;,
            &quot;is_published&quot;: true
          },
          {
            &quot;title&quot;: &quot;sem duis aliquam&quot;,
            &quot;is_published&quot;: true
          }
        ]
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;a nibh&quot;,
            &quot;is_published&quot;: true
          },
          {
            &quot;title&quot;: &quot;sit amet&quot;,
            &quot;is_published&quot;: true
          }
        ]
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sit amet&quot;,
            &quot;is_published&quot;: true
          }
        ]
      },
      {
        &quot;id&quot;: 8,
        &quot;name&quot;: &quot;April&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;vulputate elementum&quot;,
            &quot;is_published&quot;: true
          },
          {
            &quot;title&quot;: &quot;eu nibh&quot;,
            &quot;is_published&quot;: true
          }
        ]
      }
    ]
  }
}">

</div>

### Fetch if **none** of the nested objects defined via an array relationship satisfy a condition

By default a row is returned if any of the nested objects satisfy a
condition. To achieve the above, we need to frame the `where` expression
as `{_not: {condition}}`. This reads as: fetch if not (any of the nested
objects satisfy the condition) i.e. none of the nested objects satisy
the condition.

For example,

| condition                           | where expression                           |
|-------------------------------------|--------------------------------------------|
| `{object: {field: {_eq: "value"}}}` | `{_not: {object: {field: {_eq: "value"}}}` |
| `{object: {field: {_gt: "value"}}}` | `{_not: {object: {field: {_gt: "value"}}}` |

**Example:**

Fetch all authors which have none of their articles published i.e. have
`{is_published {_eq: true}`:

<div class="graphiql" view_only="" query="{
  authors(
    where: {
      _not: {
        articles: {is_published: {_eq: true}}
      }
    }
  ) {
    id
    name
    articles {
      title
      is_published
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 7,
        &quot;name&quot;: &quot;Berti&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;ipsum primis in&quot;,
            &quot;is_published&quot;: false
          }
        ]
      },
      {
        &quot;id&quot;: 10,
        &quot;name&quot;: &quot;Lyndsay&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;dui proin leo&quot;,
            &quot;is_published&quot;: false
          }
        ]
      }
    ]
  }
}">

</div>

### Fetch if nested object(s) exist/do not exist

You can filter results based on if they have nested objects by checking
if any nested objects exist. This can be achieved by using the
expression `{}` which evaluates to `true` if any object exists.

**Example where nested object(s) exist:**

Fetch all authors which have at least one article written by them:

<div class="graphiql" view_only="" query="{
  authors (
    where: {
      articles: {}
    }
  ) {
    id
    name
    articles_aggregate {
      aggregate {
        count
      }
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 2
          }
        }
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 1
          }
        }
      }
    ]
  }
}">

</div>

**Example where nested object(s) do not exist:**

Fetch all authors which have not written any articles:

<div class="graphiql" view_only="" query="{
  authors (
    where: {
      _not: {
        articles: {}
      }
    }
  ) {
    id
    name
    articles_aggregate {
      aggregate {
        count
      }
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 0
          }
        }
      },
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 0
          }
        }
      }
    ]
  }
}">

</div>

## Filter based on computed fields

You can use computed fields to filter your query results.

For example:

``` graphql
query {
  author (where: {full_name: {_ilike: "%bob%"}}){
    id
    first_name
    last_name
  }
}
```

The behaviour of the comparison operators depends on whether the
computed fields return scalar type values or set of table rows.

-   In case of scalar type, a row will be returned if the computed field
    returned scalar value satisfied the defined condition.
-   In case of table row type, a row will be returned if **any of the
    returned rows** sastisfy the defined condition.

Let's look at a few use cases based on the above:

### Fetch if the scalar value returned by the computed field satisfies a condition

**Example:**

A computed field `total_marks` defined to a `student` table which
computes the total sum of marks obtained from each subject. Fetch all
students whose total marks is above "80":

<div class="graphiql" view_only="" query="query {
  student(where: {total_marks: {_gte: 80}}){
    roll_no
    name
  }
}
:response:
 {
   &quot;data&quot;: {
     &quot;student&quot;: [
       {
         &quot;roll_no&quot;: 34,
         &quot;name&quot;: &quot;Alice&quot;
       },
       {
         &quot;roll_no&quot;: 31,
         &quot;name&quot;: &quot;Bob&quot;
       }
     ]
   }
 }">

</div>

### Fetch if **any** of the returned table rows by the computed field satisfy a condition

**Example:**

A computed field `get_published_articles` defined to a `author` table
which returns set of `article` rows published. Fetch all authors who
have atleast a published article in medicine field:

<div class="graphiql" view_only="" query="query {
  author(where: {get_published_articles: {type: {_eq: &quot;medicine&quot;}}}){
    id
    name
  }
}
:response:
{
 &quot;data&quot;: {
   &quot;author&quot;: [
     {
       &quot;id&quot;: 3,
       &quot;name&quot;: &quot;Alice&quot;
     },
     {
       &quot;id&quot;: 5,
       &quot;name&quot;: &quot;Bob&quot;
     }
   ]
 }
}">

</div>

### Fetch if aggregate value of the returned table rows by the computed field satisfies a condition

**Example:**

A computed field `get_published_articles` defined to a `author` table
which returns set of `article` rows published. Fetch all authors whose
count of published articles is more than 10:

<div class="graphiql" view_only="" query="query {
  author(where: {get_published_articles_aggregate: {count: {_gte: 10}}}){
    id
    name
  }
}
:response:
{
 &quot;data&quot;: {
   &quot;author&quot;: [
     {
       &quot;id&quot;: 5,
       &quot;name&quot;: &quot;Bob&quot;
     },
     {
       &quot;id&quot;: 7,
       &quot;name&quot;: &quot;Clarke&quot;
     }
   ]
 }
}">

</div>

## Cast a field to a different type before filtering (\_cast)

The `_cast` operator can be used to cast a field to a different type,
which allows type-specific operators to be used on fields that otherwise
would not support them. Currently, only casting between PostGIS
`geometry` and `geography` types is supported.

Casting using `_cast` corresponds directly to [SQL type
casts](https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS).

**Example: cast \`\`geometry\`\` to \`\`geography\`\`**

Filtering using `_st_d_within` over large distances can be inaccurate
for location data stored in `geometry` columns. For accurate queries,
cast the field to `geography` before comparing:

<div class="graphiql" view_only=""
query="query cities_near($point: geography!, $distance: Float!) {
  cities(
    where: {location: {
      _cast: {geography: {
        _st_d_within: {from: $point, distance: $distance}
      }}
    }}
  ) {
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;cities&quot;: [
      {
        &quot;name&quot;: &quot;London&quot;
      },
      {
        &quot;name&quot;: &quot;Paris&quot;
      }
    ]
  }
}
:variables:
{
  &quot;point&quot;: {
    &quot;type&quot;: &quot;Point&quot;,
    &quot;coordinates&quot;: [1, 50]
  },
  &quot;distance&quot;: 1000000
}">

</div>

**Example: cast \`\`geography\`\` to \`\`geometry\`\`**

Columns of type `geography` are more accurate, but they don’t support as
many operations as `geometry`. Cast to `geometry` to use those
operations in a filter:

<div class="graphiql" view_only=""
query="query cities_inside($polygon: geometry) {
  cities(
    where: {location: {
      _cast: {geometry: {
        _st_within: $polygon
      }}
    }}
  ) {
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;cities&quot;: [
      {
        &quot;name&quot;: &quot;New York&quot;
      }
    ]
  }
}
:variables:
{
  &quot;polygon&quot;: {
    &quot;type&quot;: &quot;Polygon&quot;,
    &quot;crs&quot;: {
      &quot;type&quot;: &quot;name&quot;,
      &quot;properties&quot;: { &quot;name&quot;: &quot;EPSG:4326&quot; }
    },
    &quot;coordinates&quot;: [
      [
        [-75, 40],
        [-74, 40],
        [-74, 41],
        [-75, 41],
        [-75, 40]
      ]
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

For performant queries that filter on casted fields, create an
[expression
index](https://www.postgresql.org/docs/current/indexes-expressional.html)
on the casted column. For example, if you frequently perform queries on
a field `location` of type `geometry` casted to type `geography`, you
should create an index like the following:

``` sql
CREATE INDEX cities_location_geography ON cities USING GIST ((location::geography));
```

</div>

## The TRUE expression ( **{ }** )

The expression `{}` evaluates to `true` if an object exists (even if
it's `null`).

**For example**:

-   any query with the condition `{ where: {} }` will return all objects
    without applying any filter.
-   any query with the condition `{ where: { nested_object: {} } }` will
    return all objects for which atleast one `nested_object` exists.

## Evaluation of **null** values in comparison expressions

In **versions v2.0.0 and above**, if in any comparison expression a
`null` value is passed, a type mismatch error will be thrown.

For example, the expression `{ where: {id: { _eq: null }}}` will throw
an error.

In **versions v1.3.3 and below**, if in any comparison expression a
`null` value is passed, the expression gets reduced to `{}`, the
`TRUE expression <true_expression>`.

For example, the expression `{ where: { id: {_eq: null }}}` will be
reduced to `{ where: {id: {}} }` which will return all objects for which
an `id` is set, i.e. all objects will be returned.

This behaviour can be preserved in versions v2.0.0 and above by setting
the `HASURA_GRAPHQL_V1_BOOLEAN_NULL_COLLAPSE` env var to `true`.
