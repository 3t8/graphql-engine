<div class="meta" description="Manage pagination on Postgres in Hasura"
keywords="hasura, docs, postgres, query, pagination">

</div>

# Postgres: Paginate query results

<div class="contents" backlinks="none" depth="2" local="">

Table of contents

</div>

## The **limit** & **offset** arguments

The operators `limit` and `offset` are used for pagination.

`limit` specifies the number of rows to retain from the result set and
`offset` determines which slice to retain from the results.

You can see the complete specification of the `limit` and `offset`
arguments in the `API reference <PaginationExp>`.

The following are examples of different pagination scenarios:

## Limit results

**Example:** Fetch the first 5 authors from the list of all authors:

<div class="graphiql" view_only="" query="query {
  authors(
    limit: 5
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;
      },
      {
        &quot;id&quot;: 5,
        &quot;name&quot;: &quot;Amii&quot;
      }
    ]
  }
}">

</div>

## Limit results from an offset

**Example:** Fetch 5 authors from the list of all authors, starting with
the 6th one:

<div class="graphiql" view_only="" query="query {
  authors(
    limit: 5,
    offset:5
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;Corny&quot;
      },
      {
        &quot;id&quot;: 7,
        &quot;name&quot;: &quot;Berti&quot;
      },
      {
        &quot;id&quot;: 8,
        &quot;name&quot;: &quot;April&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;name&quot;: &quot;Ninnetta&quot;
      },
      {
        &quot;id&quot;: 10,
        &quot;name&quot;: &quot;Lyndsay&quot;
      }
    ]
  }
}">

</div>

## Limit results in a nested object

**Example:** Fetch a list of authors and a list of their first 2
articles:

<div class="graphiql" view_only="" query="query {
  authors {
    id
    name
    articles (
      limit: 2
      offset: 0
    ) {
      id
      title
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles&quot;: [
          {
            &quot;id&quot;: 15,
            &quot;title&quot;: &quot;vel dapibus at&quot;
          },
          {
            &quot;id&quot;: 16,
            &quot;title&quot;: &quot;sem duis aliquam&quot;
          }
        ]
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;,
        &quot;articles&quot;: [
          {
            &quot;id&quot;: 2,
            &quot;title&quot;: &quot;a nibh&quot;
          },
          {
            &quot;id&quot;: 9,
            &quot;title&quot;: &quot;sit amet&quot;
          }
        ]
      },
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;,
        &quot;articles&quot;: [
          {
            &quot;id&quot;: 6,
            &quot;title&quot;: &quot;sapien ut&quot;
          },
          {
            &quot;id&quot;: 11,
            &quot;title&quot;: &quot;turpis eget&quot;
          }
        ]
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;,
        &quot;articles&quot;: [
          {
            &quot;id&quot;: 1,
            &quot;title&quot;: &quot;sit amet&quot;
          },
          {
            &quot;id&quot;: 3,
            &quot;title&quot;: &quot;amet justo morbi&quot;
          }
        ]
      }
    ]
  }
}">

</div>

## Keyset cursor based pagination

Cursors are used to traverse across rows of a dataset. They work by
returning a pointer to a specific row which can then be used to fetch
the next batch of data.

Keyset cursors are a column (or a set of columns) of the data that are
used as the cursor. The column(s) used as the cursor must be unique and
sequential. This ensures that data is read after a specific row rather
than relying on the position of the row in the dataset as done by
`offset`, and that duplicate records are not fetched again.

**For example**, consider the following query to fetch a list of authors
with a `where` clause used in place of `offset`:

<div class="graphiql" view_only="" query="query {
  authors(
    limit: 5,
    where: { id: {_gt: 5} }
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;Corny&quot;
      },
      {
        &quot;id&quot;: 7,
        &quot;name&quot;: &quot;Berti&quot;
      },
      {
        &quot;id&quot;: 8,
        &quot;name&quot;: &quot;April&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;name&quot;: &quot;Ninnetta&quot;
      },
      {
        &quot;id&quot;: 10,
        &quot;name&quot;: &quot;Lyndsay&quot;
      }
    ]
  }
}">

</div>

Here we are fetching authors where the value of `id` is greater than 5.
This will always skip the previously fetched results which would have
been ids 1 to 5, ensuring no duplicate results. Column `id` is acting as
the cursor here, unique and sequential.

The choice of cursor columns depends on the order of the expected
results i.e. if the query has an `order_by` clause, the column(s) used
in the `order_by` need to be used as the cursor.

Columns such as `id` (auto-incrementing integer/big integer) or
`created_at` (timestamp) are commonly used as cursors when an order is
not explicit, as they should be unique and sequential.

<div class="note">

<div class="title">

Note

</div>

Keyset cursor based pagination using `where` is more performant than
using `offset` because we can leverage database indexes on the columns
that are being used as cursors.

</div>

## Fetch limited results along with data aggregated over all results *(e.g. total count)* in the same query

Sometimes, some aggregated information on all the data is required along
with a subset of data.

E.g. the total count of results can be returned along with a page of
results. The count can then be used to calculate the number of pages
based on the limit that is set.

**Example:** Fetch a list of articles where a certain condition is true
and get their count. Then limit the number of articles to return.

<div class="graphiql" view_only=""
query="query articles ($where: articles_bool_exp!) {
  articles_aggregate(where: $where) {
    aggregate {
      totalCount: count
    }
  }
  articles (where: $where limit: 4) {
    id
    title
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles_aggregate&quot;: {
      &quot;aggregate&quot;: {
        &quot;totalCount&quot;: 8
      }
    },
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 33,
        &quot;title&quot;: &quot;How to make fajitas&quot;
      },
      {
        &quot;id&quot;: 31,
        &quot;title&quot;: &quot;How to make fajitas&quot;
      },
      {
        &quot;id&quot;: 32,
        &quot;title&quot;: &quot;How to make fajitas&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;How to climb mount everest&quot;
      }
    ]
  }
}">

</div>

<div class="admonition">

Caveat

If this needs to be done over `subscriptions <subscriptions>`, two
subscriptions will need to be run as Hasura follows the [GraphQL
spec](https://graphql.github.io/graphql-spec/June2018/#sec-Single-root-field)
which allows for only one root field in a subscription.

</div>
