<div class="meta"
description="Filter query results and search queries on MS SQL Server in Hasura"
keywords="hasura, docs, ms sql server, query, filter, search">

</div>

# MS SQL Server: Filter query results / search queries

<div class="contents" backlinks="none" depth="2" local="">

Table of contents

</div>

## The **where** argument

You can use the `where` argument in your queries to filter results based
on some field’s values (even nested objects' fields). You can even use
multiple filters in the same `where` clause using the `_and` or the
`_or` operators.

For example, to fetch data for an author whose name is "Sidney":

```graphql
query {
  authors(
    where: {name: {_eq: "Sidney"}}
  ) {
    id
    name
  }
}
```

You can also use nested objects' fields to filter rows from a table and
also filter the nested objects as well.

For example, to fetch a list of authors who have articles with a rating
greater than 4 along with those articles:

```graphql
query {
  authors (where: {articles: {rating: {_gt: 4}}}) {
    id
    name
    articles (where: {rating: {_gt: 4}}) {
      id
      title
      rating
    }
  }
}
```

Here `_eq` and `_gt` are examples of comparison operators that can be
used in the `where` argument to filter on equality.

You can see the complete specification of the `where` argument in the
`API reference <WhereExp>`.

## Comparison operators

Let’s take a look at different comparison operators that can be used to
filter results.

### Equality operators (\_eq, \_neq)

The `_eq` (equal to) or the `_neq` (not equal to) operators are
compatible with any MS SQL Server type (like `Integer`, `Float`,
`Double`, `Text`, `Boolean`, `Date`/`Time`/`Timestamp`, etc.).

The following are examples of using the equality operators on different
types.

**Example: Integer (works with Double, Float, Int, etc.)**

Fetch data about an author whose `id` *(an integer field)* is equal to
3:

<div class="graphiql" view_only="" query="query {
  authors(
    where: {id: {_eq: 3}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;
      }
    ]
  }
}">

</div>

**Example: String or Text**

Fetch a list of authors with `name` *(a text field)* as "Sidney":

<div class="graphiql" view_only="" query="query {
  authors(
    where: {name: {_eq: &quot;Sidney&quot;}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;
      }
    ]
  }
}">

</div>

**Example: Boolean**

Fetch a list of articles that have not been published (`is_published` is
a boolean field):

<div class="graphiql" view_only="" query="query {
  articles(
    where: {is_published: {_eq: false}}
  ) {
    id
    title
    is_published
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 5,
        &quot;title&quot;: &quot;ut blandit&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 8,
        &quot;title&quot;: &quot;donec semper sapien&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 10,
        &quot;title&quot;: &quot;dui proin leo&quot;,
        &quot;is_published&quot;: false
      },
      {
        &quot;id&quot;: 14,
        &quot;title&quot;: &quot;congue etiam justo&quot;,
        &quot;is_published&quot;: false
      }
    ]
  }
}">

</div>

**Example: Date (works with Time, Timezone, etc.)**

Fetch a list of articles that were published on a certain date
(`published_on` is a Date field):

<div class="graphiql" view_only="" query="query {
  articles(
    where: {published_on: {_eq: &quot;2017-05-26&quot;}}
  ) {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      }
    ]
  }
}">

</div>

### Greater than or less than operators (\_gt, \_lt, \_gte, \_lte)

The `_gt` (greater than), `_lt` (less than), `_gte` (greater than or
equal to), `_lte` (less than or equal to) operators are compatible with
any MS SQL Server type (like `Integer`, `Float`, `Double`, `Text`,
`Boolean`, `Date`/`Time`/`Timestamp`, etc.).

The following are examples of using these operators on different types:

**Example: Integer (works with Double, Float, etc.)**

Fetch a list of articles rated 4 or more (`rating` is an integer field):

<div class="graphiql" view_only="" query="query {
  articles(
    where: {rating: {_gte: 4}}
  ) {
    id
    title
    rating
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;rating&quot;: 4
      },
      {
        &quot;id&quot;: 7,
        &quot;title&quot;: &quot;nisl duis ac&quot;,
        &quot;rating&quot;: 4
      },
      {
        &quot;id&quot;: 17,
        &quot;title&quot;: &quot;montes nascetur ridiculus&quot;,
        &quot;rating&quot;: 5
      }
    ]
  }
}">

</div>

**Example: String or Text**

Fetch a list of authors whose names begin with M or any letter that
follows M *(essentially, a filter based on a dictionary sort)*:

<div class="graphiql" view_only="" query="query {
  authors(
    where: {name: {_gt: &quot;M&quot;}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;name&quot;: &quot;Ninnetta&quot;
      }
    ]
  }
}">

</div>

**Example: Date (works with Time, Timezone, etc.)**

Fetch a list of articles that were published on or after date
"01/01/2018":

<div class="graphiql" view_only="" query="query {
  articles(
    where: {published_on: {_gte: &quot;2018-01-01&quot;}}
  ) {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;published_on&quot;: &quot;2018-06-10&quot;
      },
      {
        &quot;id&quot;: 6,
        &quot;title&quot;: &quot;sapien ut&quot;,
        &quot;published_on&quot;: &quot;2018-01-08&quot;
      },
      {
        &quot;id&quot;: 13,
        &quot;title&quot;: &quot;vulputate elementum&quot;,
        &quot;published_on&quot;: &quot;2018-03-10&quot;
      },
      {
        &quot;id&quot;: 15,
        &quot;title&quot;: &quot;vel dapibus at&quot;,
        &quot;published_on&quot;: &quot;2018-01-02&quot;
      }
    ]
  }
}">

</div>

### List based search operators (\_in, \_nin)

The `_in` (in a list) and `_nin` (not in list) operators are used to
compare field values to a list of values. They are compatible with any
MS SQL Server type (like `Integer`, `Float`, `Double`, `Text`,
`Boolean`, `Date`/`Time`/`Timestamp`, etc.).

The following are examples of using these operators on different types:

**Example: Integer (works with Double, Float, etc.)**

Fetch a list of articles rated 1, 3 or 5:

<div class="graphiql" view_only="" query="query {
  articles(
    where: {rating: {_in: [1,3,5]}}
  ) {
    id
    title
    rating
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;rating&quot;: 1
      },
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;rating&quot;: 3
      },
      {
        &quot;id&quot;: 6,
        &quot;title&quot;: &quot;sapien ut&quot;,
        &quot;rating&quot;: 1
      },
      {
        &quot;id&quot;: 17,
        &quot;title&quot;: &quot;montes nascetur ridiculus&quot;,
        &quot;rating&quot;: 5
      }
    ]
  }
}">

</div>

**Example: String or Text**

Fetch a list of those authors whose names are NOT part of a list:

<div class="graphiql" view_only="" query="query {
  authors(
    where: {name: {_nin: [&quot;Justin&quot;,&quot;Sidney&quot;,&quot;April&quot;]}}
  ) {
    id
    name
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;
      },
      {
        &quot;id&quot;: 5,
        &quot;name&quot;: &quot;Amii&quot;
      },
      {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;Corny&quot;
      }
    ]
  }
}">

</div>

### Text search or pattern matching operators (\_like)

The `_like`, `_nlike` operators are used for pattern matching on
string/text fields.

**Example: \_like**

Fetch a list of articles whose titles contain the word “amet”:

<div class="graphiql" view_only="" query="query {
  articles(
    where: {title: {_like: &quot;%amet%&quot;}}
  ) {
    id
    title
  }
}
:response:
{
&quot;data&quot;: {
  &quot;articles&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;title&quot;: &quot;sit amet&quot;
    },
    {
      &quot;id&quot;: 3,
      &quot;title&quot;: &quot;amet justo morbi&quot;
    },
    {
      &quot;id&quot;: 9,
      &quot;title&quot;: &quot;sit amet&quot;
    }
  ]">

</div>

### Spatial relationship operators (\_st_contains, \_st_crosses, etc.)

The `_st_contains`, `_st_crosses`, `_st_equals`, `_st_intersects`,
`_st_overlaps`, `_st_touches`, `_st_within` operators are used to filter
based on `geometry` like columns.

`_st_intersects` can be used on `geography` columns also.

Use JSON representation (see
[GeoJSON](https://tools.ietf.org/html/rfc7946)) of `geometry` and
`geography` values in `variables` as shown in the following examples:

**Example: \_st_within**

Fetch a list of geometry values which are within the given `polygon`
value:

<div class="graphiql" view_only=""
query="query geom_table($polygon: geometry){
  geom_table(
    where: {geom_col: {_st_within: $polygon}}
  ){
    id
    geom_col
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;geom_table&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;geom_col&quot;: {
          &quot;type&quot;: &quot;Point&quot;,
          &quot;coordinates&quot;: [
            1,
            2
          ]
        }
      }
    ]
  }
}
:variables:
{
  &quot;polygon&quot;: {
    &quot;type&quot;: &quot;Polygon&quot;,
    &quot;coordinates&quot;: [
      [
        [ 0, 0 ],
        [ 0, 2 ],
        [ 2, 2 ],
        [ 2, 0 ],
        [ 0, 0 ]
      ]
    ]
  }
}">

</div>

### Filter or check for null values (\_is_null)

Checking for null values can be achieved using the `_is_null` operator.

**Example: Filter null values in a field**

Fetch a list of articles that have a value in the `published_on` field:

<div class="graphiql" view_only="" query="query {
  articles(
    where: {published_on: {_is_null: false}}
  ) {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;published_on&quot;: &quot;2017-08-09&quot;
      },
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;published_on&quot;: &quot;2018-06-10&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      },
      {
        &quot;id&quot;: 4,
        &quot;title&quot;: &quot;vestibulum ac est&quot;,
        &quot;published_on&quot;: &quot;2017-03-05&quot;
      }
    ]
  }
}">

</div>

## Filter based on failure of some criteria (\_not)

The `_not` operator can be used to fetch results for which some
condition does not hold true. i.e. to invert the filter set for a
condition.

**Example: \_not**

Fetch all authors who don't have any published articles:

<div class="graphiql" view_only="" query="{
  authors(
    where: {
      _not: {
        articles: { is_published: {_eq: true} }
      }
    }) {
    id
    name
    articles {
      title
      is_published
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 7,
        &quot;name&quot;: &quot;Berti&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;ipsum primis in&quot;,
            &quot;is_published&quot;: false
          }
        ]
      },
      {
        &quot;id&quot;: 9,
        &quot;name&quot;: &quot;Ninnetta&quot;,
        &quot;articles&quot;: []
      },
      {
        &quot;id&quot;: 10,
        &quot;name&quot;: &quot;Lyndsay&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;dui proin leo&quot;,
            &quot;is_published&quot;: false
          }
        ]
      }
    ]
  }
}">

</div>

## Using multiple filters in the same query (\_and, \_or)

You can group multiple parameters in the same `where` argument using the
`_and` or the `_or` operators to filter results based on more than one
criteria.

<div class="note">

<div class="title">

Note

</div>

You can use the `_or` and `_and` operators along with the `_not`
operator to create arbitrarily complex boolean expressions involving
multiple filtering criteria.

</div>

**Example: \_and**

Fetch a list of articles published in a specific time-frame (for
example: in year 2017):

<div class="graphiql" view_only="" query="query {
  articles (
    where: {
      _and: [
        { published_on: {_gte: &quot;2017-01-01&quot;}},
        { published_on: {_lte: &quot;2017-12-31&quot;}}
      ]
    }
  )
  {
    id
    title
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;published_on&quot;: &quot;2017-08-09&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      },
      {
        &quot;id&quot;: 4,
        &quot;title&quot;: &quot;vestibulum ac est&quot;,
        &quot;published_on&quot;: &quot;2017-03-05&quot;
      },
      {
        &quot;id&quot;: 9,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;published_on&quot;: &quot;2017-05-16&quot;
      }
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

Certain `_and` expressions can be expressed in a simpler format using
some syntactic sugar. See the `API reference <AndExp>` for more details.

</div>

**Example: \_or**

Fetch a list of articles rated more than 4 or published after
"01/01/2018":

<div class="graphiql" view_only="" query="query {
  articles (
    where: {
      _or: [
        {rating: {_gte: 4}},
        {published_on: {_gte: &quot;2018-01-01&quot;}}
      ]
    }
  )
  {
    id
    title
    rating
    published_on
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;title&quot;: &quot;a nibh&quot;,
        &quot;rating&quot;: 3,
        &quot;published_on&quot;: &quot;2018-06-10&quot;
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;rating&quot;: 4,
        &quot;published_on&quot;: &quot;2017-05-26&quot;
      },
      {
        &quot;id&quot;: 6,
        &quot;title&quot;: &quot;sapien ut&quot;,
        &quot;rating&quot;: 1,
        &quot;published_on&quot;: &quot;2018-01-08&quot;
      },
      {
        &quot;id&quot;: 7,
        &quot;title&quot;: &quot;nisl duis ac&quot;,
        &quot;rating&quot;: 4,
        &quot;published_on&quot;: &quot;2016-07-09&quot;
      }
    ]
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

The `_or` operator expects an array of expressions as input. If an
object is passed as input it will behave like the `_and` operator as
explained in the `API reference <OrExp>`

</div>

## Filter nested objects

The `where` argument can be used in **array relationships** as well to
filter the nested objects. **Object relationships** have only one nested
object and hence they do not expose the `where` argument.

**Example:**

Fetch all authors with only their 5 rated articles:

<div class="graphiql" view_only="" query="{
  authors {
    id
    name
    articles(where: {rating: {_eq: 5}}) {
      title
      rating
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles&quot;: []
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;,
        &quot;articles&quot;: []
      },
      {
        &quot;id&quot;: 5,
        &quot;name&quot;: &quot;Amii&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;montes nascetur ridiculus&quot;,
            &quot;rating&quot;: 5
          }
        ]
      },
      {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;Corny&quot;,
        &quot;articles&quot;: []
      }
    ]
  }
}">

</div>

## Filter based on nested objects' fields

You can use the fields of nested objects as well to filter your query
results.

For example:

```graphql
query {
  articles (where: {author: {name: {_eq: "Sidney"}}}) {
    id
    title
  }
}
```

The behaviour of the comparison operators depends on whether the nested
objects are a single object related via an object relationship or an
array of objects related via an array relationship.

-   In case of an **object relationship**, a row will be returned if the
    single nested object satisfies the defined condition.
-   In case of an **array relationship**, a row will be returned if
    **any of the nested objects** satisfy the defined condition.

Let's look at a few use cases based on the above:

### Fetch if the single nested object defined via an object relationship satisfies a condition

**Example:**

Fetch all articles whose author's name starts with "A":

<div class="graphiql" view_only="" query="{
  articles (
    where: {
      author: {
        name: { _like: &quot;A%&quot;}
      }
    }
  ) {
    id
    title
    author {
      name
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;articles&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;sit amet&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Anjela&quot;
        }
      },
      {
        &quot;id&quot;: 3,
        &quot;title&quot;: &quot;amet justo morbi&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Anjela&quot;
        }
      },
      {
        &quot;id&quot;: 4,
        &quot;title&quot;: &quot;vestibulum ac est&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Amii&quot;
        }
      },
      {
        &quot;id&quot;: 12,
        &quot;title&quot;: &quot;volutpat quam pede&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;Amii&quot;
        }
      },
      {
        &quot;id&quot;: 13,
        &quot;title&quot;: &quot;vulputate elementum&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;April&quot;
        }
      }
    ]
  }
}">

</div>

### Fetch if **any** of the nested objects defined via an array relationship satisfy a condition

**Example:**

Fetch all authors which have written at least one article which is rated
1:

<div class="graphiql" view_only="" query="{
  authors(
    where: {
      articles: {rating: {_eq: 1}}
    }
  ) {
    id
    name
    articles {
      title
      rating
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sem duis aliquam&quot;,
            &quot;rating&quot;: 1
          },
          {
            &quot;title&quot;: &quot;vel dapibus at&quot;,
            &quot;rating&quot;: 4
          }
        ]
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sit amet&quot;,
            &quot;rating&quot;: 1
          },
          {
            &quot;title&quot;: &quot;amet justo morbi&quot;,
            &quot;rating&quot;: 4
          }
        ]
      },
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sapien ut&quot;,
            &quot;rating&quot;: 1
          },
          {
            &quot;title&quot;: &quot;turpis eget&quot;,
            &quot;rating&quot;: 3
          },
          {
            &quot;title&quot;: &quot;congue etiam justo&quot;,
            &quot;rating&quot;: 4
          }
        ]
      }
    ]
  }
}">

</div>

### Fetch if **all** of the nested objects defined via an array relationship satisfy a condition

By default a row is returned if any of the nested objects satisfy a
condition. To achieve the above, we need to frame the `where` expression
as `{_not: {inverse-of-condition}}`. This reads as: fetch if not (any of
the nested objects satisfy the inverted condition) i.e. all of the
nested objects satisfy the condition.

For example:

| condition                           | where expression                            |
|-------------------------------------|---------------------------------------------|
| `{object: {field: {_eq: "value"}}}` | `{_not: {object: {field: {_neq: "value"}}}` |
| `{object: {field: {_gt: "value"}}}` | `{_not: {object: {field: {_lte: "value"}}}` |

**Example:**

Fetch all authors which have all of their articles published i.e. have
`{is_published {_eq: true}`.

<div class="graphiql" view_only="" query="{
  authors (
    where: {
      _not: {
        articles: {is_published: {_neq: true}}
      }
    }
  ) {
    id
    name
    articles {
      title
      is_published
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;vel dapibus at&quot;,
            &quot;is_published&quot;: true
          },
          {
            &quot;title&quot;: &quot;sem duis aliquam&quot;,
            &quot;is_published&quot;: true
          }
        ]
      },
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;a nibh&quot;,
            &quot;is_published&quot;: true
          },
          {
            &quot;title&quot;: &quot;sit amet&quot;,
            &quot;is_published&quot;: true
          }
        ]
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;sit amet&quot;,
            &quot;is_published&quot;: true
          }
        ]
      },
      {
        &quot;id&quot;: 8,
        &quot;name&quot;: &quot;April&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;vulputate elementum&quot;,
            &quot;is_published&quot;: true
          },
          {
            &quot;title&quot;: &quot;eu nibh&quot;,
            &quot;is_published&quot;: true
          }
        ]
      }
    ]
  }
}">

</div>

### Fetch if **none** of the nested objects defined via an array relationship satisfy a condition

By default a row is returned if any of the nested objects satisfy a
condition. To achieve the above, we need to frame the `where` expression
as `{_not: {condition}}`. This reads as: fetch if not (any of the nested
objects satisfy the condition) i.e. none of the nested objects satisy
the condition.

For example,

| condition                           | where expression                           |
|-------------------------------------|--------------------------------------------|
| `{object: {field: {_eq: "value"}}}` | `{_not: {object: {field: {_eq: "value"}}}` |
| `{object: {field: {_gt: "value"}}}` | `{_not: {object: {field: {_gt: "value"}}}` |

**Example:**

Fetch all authors which have none of their articles published i.e. have
`{is_published {_eq: true}`:

<div class="graphiql" view_only="" query="{
  authors(
    where: {
      _not: {
        articles: {is_published: {_eq: true}}
      }
    }
  ) {
    id
    name
    articles {
      title
      is_published
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 7,
        &quot;name&quot;: &quot;Berti&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;ipsum primis in&quot;,
            &quot;is_published&quot;: false
          }
        ]
      },
      {
        &quot;id&quot;: 10,
        &quot;name&quot;: &quot;Lyndsay&quot;,
        &quot;articles&quot;: [
          {
            &quot;title&quot;: &quot;dui proin leo&quot;,
            &quot;is_published&quot;: false
          }
        ]
      }
    ]
  }
}">

</div>

### Fetch if nested object(s) exist/do not exist

You can filter results based on if they have nested objects by checking
if any nested objects exist. This can be achieved by using the
expression `{}` which evaluates to `true` if any object exists.

**Example where nested object(s) exist:**

Fetch all authors which have at least one article written by them:

<div class="graphiql" view_only="" query="{
  authors (
    where: {
      articles: {}
    }
  ) {
    id
    name
    articles_aggregate {
      aggregate {
        count
      }
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Justin&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 2
          }
        }
      },
      {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;Anjela&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 1
          }
        }
      }
    ]
  }
}">

</div>

**Example where nested object(s) do not exist:**

Fetch all authors which have not written any articles:

<div class="graphiql" view_only="" query="{
  authors (
    where: {
      _not: {
        articles: {}
      }
    }
  ) {
    id
    name
    articles_aggregate {
      aggregate {
        count
      }
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;authors&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;Beltran&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 0
          }
        }
      },
      {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;Sidney&quot;,
        &quot;articles_aggregate&quot;: {
          &quot;aggregate&quot;: {
            &quot;count&quot;: 0
          }
        }
      }
    ]
  }
}">

</div>

## The TRUE expression ( **{ }** )

The expression `{}` evaluates to `true` if an object exists (even if
it's `null`).

**For example**:

-   any query with the condition `{ where: {} }` will return all objects
    without applying any filter.
-   any query with the condition `{ where: { nested_object: {} } }` will
    return all objects for which atleast one `nested_object` exists.

## Evaluation of **null** values in comparison expressions

If in any comparison expression a `null` value is passed, a type
mismatch error will be thrown.

For example, the expression `{ where: {id: { _eq: null }}}` will throw
an error.
